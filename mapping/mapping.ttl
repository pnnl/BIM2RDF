@prefix brick: <https://brickschema.org/schema/Brick#> .
@prefix lighting: <https://example.com/pnnl/lighting/> .
@prefix sh: <http://www.w3.org/ns/shacl#> .
@prefix schema: <http://schema.org/> .
@prefix owl: <http://www.w3.org/2002/07/owl#> .
@prefix qudt: <http://qudt.org/schema/qudt/> .
@prefix xsd: <http://www.w3.org/2001/XMLSchema#> .


@prefix bdg:  <http://example.com/>.
@prefix spkl:  <http://speckle.systems/>.
@prefix spklsh: <http://speckle.systems/shape/>.
# constraints for how i'm expecting things
# and 'rules' for mapping


# this is some kind of skolemization...
# ...which was too complicated to handle as a rule/transform
# ...so it was handled in the jsonld to rdf conversion
# # but maybe could have used owl:SameAs
# [(anon(blank), 'id', id)  ->  (id, *, *)
# (anon(blank), *, *)]
# need to de-anonymize.
# spklsh:id a sh:NodeShape;
#     sh:targetObjectsOf spkl:id;
#     # could enforce speckle_type should be along with id
#     sh:rule [a sh:TripleRule;
#         sh:subject      sh:this;
#         sh:predicate    spkl:id;
#         sh:object       'asdf';].


# lets go with brick
spkl:fixtures a sh:NodeShape;
    sh:target [ a sh:SPARQLTarget;
        #sh:prefixes put this TODO
        # dont know how to express this as a Node, SubjectOf, or ObjectOf target
        sh:select """
        prefix spkl: <http://speckle.systems/>
        select ?this 
        where {
	    ?this spkl:category  "Lighting Fixtures".
        }
        """;];
    sh:rule [a sh:SPARQLRule;
        #sh:prefixes brick:brick;
        sh:construct """
        PREFIX spkl: <http://speckle.systems/>
        PREFIX unit: <http://qudt.org/vocab/unit/>
        prefix brick: <https://brickschema.org/schema/Brick#>

        construct {
            ?this a brick:Luminaire.
            ?this brick:Power [ # no such thing as brick:Power though
                brick:value   ?watts;
                brick:hasUnit unit:W;].}
        where {
            ?this spkl:parameters/spkl:FBX_LIGHT_WATTAGE/spkl:value ?watts.}
        """;].
    



